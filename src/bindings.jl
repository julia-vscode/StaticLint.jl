mutable struct ImportBinding
    loc::Location
    si::SIndex
    val
end

mutable struct Binding
    loc::Location
    si::SIndex
    val
    t
end

Base.display(b::Binding) = println(b.si," @ ",  basename(b.loc.file), ":", b.loc.offset)
Base.display(B::Array{Binding}) = for b in B display(b) end

function add_binding(name, x, state, s, t = nothing)
    # global bindinglist
    s.bindings += 1
    val = Binding(StaticLint.Location(state), SIndex(s.index, s.bindings), x, t)
    add_binding(name, val, state.bindings)
end

function add_binding(name, binding, bindings::Dict{String,Vector{Binding}})
    if haskey(bindings, name)
        push!(bindings[name], binding)
    else
        bindings[name] = Binding[binding]
    end
end

# Gets bindings added to the current scope which an expression is in: modules, functions, macros, datatype declarations, variables and imported bindings.
function ext_binding(x, state, s)
    if CSTParser.defines_module(x)
        name = CSTParser.str_value(CSTParser.get_name(x))
        add_binding(name, x, state, s, CSTParser.ModuleH)
    elseif CSTParser.defines_function(x)
        name = CSTParser.str_value(CSTParser.get_name(x))
        add_binding(name, x, state, s, CSTParser.FunctionDef)
    elseif CSTParser.defines_macro(x)
        name = string("@", CSTParser.str_value(CSTParser.get_name(x)))
        add_binding(name, x, state, s, CSTParser.Macro)
    elseif CSTParser.defines_datatype(x)
        t = CSTParser.defines_abstract(x) ? CSTParser.Abstract :
            CSTParser.defines_primitive(x) ? CSTParser.Primitive :
            CSTParser.defines_mutable(x) ? CSTParser.Mutable :
            CSTParser.Struct             
        name = CSTParser.str_value(CSTParser.get_name(x))
        add_binding(name, x, state, s, t)
    elseif CSTParser.is_assignment(x)
        ass = x.arg1
        ass = CSTParser.rem_decl(ass)
        ass = CSTParser.rem_curly(ass)
        if ass isa CSTParser.IDENTIFIER
            name = CSTParser.str_value(ass)
            add_binding(name, x, state, s)
        elseif ass isa CSTParser.EXPR{CSTParser.TupleH}
            for a in CSTParser.flatten_tuple(ass)
                name = CSTParser.str_value(CSTParser.get_name(a))
                add_binding(name, x, state, s)
            end
        end
    elseif x isa CSTParser.EXPR{CSTParser.Using} || x isa CSTParser.EXPR{CSTParser.Import} || x isa CSTParser.EXPR{CSTParser.ImportAll}
        get_imports(x, state, s)
    elseif x isa CSTParser.EXPR{CSTParser.Export}
        add_export_bindings(x, state, s)
    elseif x isa CSTParser.EXPR{CSTParser.MacroCall} && x.args[1] isa CSTParser.EXPR{CSTParser.MacroName} && length(x.args[1].args) > 1 &&  CSTParser.str_value(x.args[1].args[2]) == "enum"
        # Special case for enums.
        if length(x.args) > 3 && x.args[3] isa CSTParser.IDENTIFIER
            add_binding(CSTParser.str_value(x.args[3]), x, state, s)
        end
        for i = 4:length(x.args)
            if x.args[i] isa CSTParser.IDENTIFIER
                name = CSTParser.str_value(x.args[i])
                add_binding(name, x, state, s)
            end
        end
    elseif x isa CSTParser.WhereOpCall
        for arg in x.args
            arg isa CSTParser.PUNCTUATION && continue
            add_binding(CSTParser.str_value(CSTParser.rem_curly(CSTParser.rem_subtype(arg))), x, state, s)
        end 
    end
end

function add_export_bindings(x, state, s)
    if !haskey(state.exports, s.index)
        state.exports[s.index] = []
    end
    for i = 2:length(x.args)
        arg = x.args[i]
        !(arg isa CSTParser.IDENTIFIER) && continue
        push!(state.exports[s.index], CSTParser.str_value(arg))
    end
end

# Gets bindings that are created inside the scope generated by an expression.
function int_binding(x, state, s)
    if CSTParser.defines_module(x)
        name = CSTParser.str_value(CSTParser.get_name(x))
        add_binding(name, x, state, s, CSTParser.ModuleH)
    elseif CSTParser.defines_function(x) || CSTParser.defines_macro(x)
        get_fcall_bindings(CSTParser.get_sig(x), state, s)
    elseif CSTParser.defines_datatype(x)
        if x isa CSTParser.EXPR{CSTParser.Struct} || x isa CSTParser.EXPR{CSTParser.Mutable}
            get_struct_bindings(x, state, s)
        end
    elseif x isa CSTParser.EXPR{CSTParser.For}
        if is_for_iter(x.args[2])
            for a in CSTParser.flatten_tuple(x.args[2].arg1)
                add_binding(CSTParser.str_value(CSTParser.get_name(a)), x, state, s)
            end
        else
            for i = 1:length(x.args[2].args)
                if is_for_iter(x.args[2].args[i])
                    for a in CSTParser.flatten_tuple(x.args[2].args[i].arg1)
                        add_binding(CSTParser.str_value(CSTParser.get_name(a)), x, state, s)
                    end
                end
            end
        end
    elseif x isa CSTParser.EXPR{CSTParser.Do}
        for arg in CSTParser.flatten_tuple(x.args[3])
            name = CSTParser.str_value(CSTParser.get_name(arg))
            add_binding(name, x, state, s)
        end
    elseif x isa CSTParser.EXPR{CSTParser.Generator}
        if is_for_iter(x.args[3])
            for i = 3:length(x.args)
                !is_for_iter(x.args[i]) && continue
                for arg in CSTParser.flatten_tuple(x.args[i].arg1)
                    name = CSTParser.str_value(CSTParser.get_name(arg))
                    add_binding(name, x, state, s)
                end
                # name = CSTParser.str_value(CSTParser.get_name(x.args[i].arg1))
                # add_binding(name, x, state, s)
            end
        elseif x.args[3] isa CSTParser.EXPR{CSTParser.Filter}
            for i = 1:length(x.args[3].args)
                !is_for_iter(x.args[3].args[i]) && continue
                name = CSTParser.str_value(CSTParser.get_name(x.args[3].args[i].arg1))
                add_binding(name, x, state, s)
            end
        end
    elseif CSTParser.defines_anon_function(x)
        for arg in CSTParser.flatten_tuple(x.arg1)
            name = CSTParser.str_value(CSTParser.get_name(arg))
            add_binding(name, x, state, s)
        end
    end
end

function is_for_iter(x)
    (x isa CSTParser.BinarySyntaxOpCall || x isa CSTParser.BinaryOpCall) && x.op.kind in (CSTParser.Tokens.IN, CSTParser.Tokens.ELEMENT_OF, CSTParser.Tokens.EQ)
end

function get_iter_args(x::CSTParser.BinarySyntaxOpCall, state, s)
    name = CSTParser.str_value(CSTParser.get_name(x.args[3].args[i].arg1))
    add_binding(name, x, state, s)
end

function get_fcall_args(sig, getparams = true)
    args = Pair[]
    while sig isa CSTParser.WhereOpCall
        for arg in sig.args
            arg isa CSTParser.PUNCTUATION && continue
            push!(args, CSTParser.rem_curly(CSTParser.rem_subtype(arg))=>DataType)
        end 
        sig = sig.arg1
    end
    if sig isa CSTParser.BinarySyntaxOpCall && CSTParser.is_decl(sig.op)
        sig = sig.arg1
    end
    sig isa CSTParser.IDENTIFIER && return args
    if sig isa CSTParser.EXPR{CSTParser.Call} && sig.args[1] isa CSTParser.EXPR{CSTParser.Curly}
        for i = 2:length(sig.args[1].args)
            arg = sig.args[1].args[i]
            arg isa CSTParser.PUNCTUATION && continue
            push!(args, CSTParser.rem_subtype(arg)=>DataType)
        end
    end
    !getparams && empty!(args)
    !(sig isa CSTParser.EXPR) && return args
    for i = 3:length(sig.args)-1
        arg = sig.args[i]
        arg isa CSTParser.PUNCTUATION && continue
        get_arg_type(arg, args)
    end
    return args
end
function get_fcall_bindings(sig, state, s)
    args = get_fcall_args(sig)
    for (arg, t) in args
        add_binding(CSTParser.str_value(arg), sig, state, s, t)
    end
end

function get_struct_bindings(x, state, s)
    isstruct = x isa CSTParser.EXPR{CSTParser.Struct}
    sig = CSTParser.get_sig(x)
    sig = CSTParser.rem_subtype(sig)
    sig = CSTParser.rem_where(sig)
    for arg in CSTParser.get_curly_params(sig)
        add_binding(arg, x, state, s, DataType)
    end
    for arg in x.args[isstruct ? 3 : 4]
        if !CSTParser.defines_function(arg)
            if arg isa CSTParser.BinarySyntaxOpCall && CSTParser.is_decl(arg.op)
                name = CSTParser.str_value(arg.arg1)
                t = arg.arg2
            else
                name = CSTParser.str_value(arg)
                t = nothing
            end
            add_binding(name, x, state, s, t)
        end
    end
end

function get_arg_type(arg, args)
    if arg isa CSTParser.UnarySyntaxOpCall && CSTParser.is_dddot(arg.arg2)
        arg = arg.arg1
    end
    if arg isa CSTParser.IDENTIFIER
        push!(args, arg=>nothing)
    elseif arg isa CSTParser.BinarySyntaxOpCall && CSTParser.is_decl(arg.op)
        push!(args, arg.arg1=>arg.arg2)
    elseif arg isa CSTParser.EXPR{CSTParser.Kw}
        if arg.args[1] isa CSTParser.BinarySyntaxOpCall && CSTParser.is_decl(arg.args[1].op)
            push!(args, arg.args[1].arg1=>arg.args[1].arg2)
        elseif arg.args[3] isa CSTParser.LITERAL
            push!(args, arg.args[1]=>arg.args[3].kind)
        else
            push!(args, arg.args[1]=>nothing)
        end
    end
end
function get_arg_type(arg::CSTParser.EXPR{CSTParser.Parameters}, args)
    for a in arg.args
        get_arg_type(a, args)
    end
end

function _store_search(strs, store, i = 1, bs = [])
    if haskey(store, strs[i])
        push!(bs, store[strs[i]])
        if i == length(strs)
            return bs
        else
            return _store_search(strs, store[strs[i]], i+1, bs)
        end
    else
        return nothing
    end
end

function get_imports(x, state, s)
    push!(state.imports, ImportBinding(Location(state), SIndex(s.index, s.bindings), x))
    # ensure we add (at least) enough binding slots
    s.bindings += length(x.args)
end

function cat_bindings(server, file, vars = State())
    for (name,bs) in file.state.bindings
        if !haskey(vars.bindings, name)
            vars.bindings[name] = Binding[]
        end
        append!(vars.bindings[name], bs)
    end
    append!(vars.modules, file.state.modules)
    append!(vars.imports, file.state.imports)
    
    for (name,bs) in file.state.exports
        if !haskey(vars.exports, name)
            vars.exports[name] = []
        end
        append!(vars.exports[name], bs)
    end
    for (name,bs) in file.state.used_modules
        vars.used_modules[name] = bs
    end
    
    
    for incl in file.state.includes
        cat_bindings(server, getfile(server, incl.file), vars)
    end
    return vars
end



function build_bindings(server, file)
    state = cat_bindings(server, file)
    # add imports
    state.used_modules = Dict{String,Any}("Base" => Binding(Location(file.state), SIndex(file.index, file.nb), store["Base"], store["Core"]["Module"]),
    "Core" => Binding(Location(file.state), SIndex(file.index, file.nb), store["Core"], store["Core"]["Module"]))
    resolve_imports(state)
    return state
end

function resolve_imports(state)
    for imprt in state.imports
        x = imprt.val
        u = x isa CSTParser.EXPR{CSTParser.Using}
        i = 2
        predots = 0
        root = []
        block = []
        while i â‰¤ length(x.args)
            arg = x.args[i]
            if arg isa Union{CSTParser.PUNCTUATION,CSTParser.OPERATOR} && arg.kind == CSTParser.Tokens.DOT
                if isempty(block)
                    predots += 1
                end
            elseif arg isa CSTParser.PUNCTUATION && arg.kind == CSTParser.Tokens.COMMA   
                add_import_binding(state, imprt, root, block, predots, u)
                empty!(block)
            elseif arg isa CSTParser.OPERATOR && arg.kind == CSTParser.Tokens.COLON
                root = block
                block = []
            elseif arg isa CSTParser.IDENTIFIER
                push!(block, arg)
            else 
                return
            end
            i += 1
        end
        if !isempty(block)
            add_import_binding(state, imprt, root, block, predots, u)
        end
    end
end


function import_local(full_name_cst, si, state)
    name = CSTParser.str_value(first(full_name_cst))
    if length(full_name_cst) > 1
        root = find_binding(state.bindings, name, b -> b.t == CSTParser.ModuleH && b.si.i == si.i && b.si.n >= si.n)
        if !isempty(root)
            popfirst!(full_name_cst)
            return import_local(full_name_cst, last(root).si, state)
        end
    else
        val = find_binding(state.bindings, name, b -> b.si.i == si.i && b.si.n >= si.n)
        if !isempty(val)
            return last(val)
        end
    end
    return 
end


function add_import_binding(state, imprt, root, block, predots, u)
    strs = CSTParser.str_value.(block)
    full_name = join(strs, ".")
    if full_name in store[".importable_mods"]
        binding = Binding(imprt.loc, imprt.si, _store_search(strs, store)[end], store["Core"]["Module"])
        if haskey(state.bindings, last(strs))
            push!(state.bindings[last(strs)], binding)
        else
            state.bindings[last(strs)] = [binding]
        end
        if u
            state.used_modules[last(strs)] = binding
        end
    elseif predots > 0
        full_name_cst = vcat(root, block)
        ms = find_binding(state.bindings, CSTParser.str_value(first(full_name_cst)), b->b.t == CSTParser.ModuleH)

        if length(ms) >= 2 && length(imprt.si.i) >= predots-1
            si = predots > 1 ? shrink_sindex(imprt.si, predots - 1) : imprt.si
            ext_i = findfirst(m->m.si.i == si.i, ms) #find module binding in this scope
            ext_i == nothing || length(ms) <= ext_i && return

            ext_m = ms[ext_i] # outer bindings
            int_m = ms[ext_i+1] # inner reference within module scope
            
            b = import_local(full_name_cst, int_m.si, state)
            if b.val isa Union{CSTParser.ModuleH,CSTParser.BareModule}
            elseif b.val isa CSTParser.AbstractEXPR
                add_binding(CSTParser.str_value(last(full_name_cst)), Binding(b.loc, imprt.si, b.val, b.t), state.bindings)
            end            
        end
    else
        if !isempty(root)
            strs = CSTParser.str_value.(vcat(root, block))
        end
        bs = _store_search(strs, store)
        if bs!=nothing
            add_binding(last(strs), Binding(imprt.loc, imprt.si, last(bs), nothing), state.bindings)
        end
    end
end


function find_binding(bindings, name, st::Function = x->true)
    out = Binding[]
    if haskey(bindings, name)
        for b in bindings[name]
            if st(b)
                push!(out, b)
            end
        end
    end
    return out
end
